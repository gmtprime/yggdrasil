defmodule Yggdrasil.Adapter.Elixir do
  @moduledoc """
  Default Elixir adapter. Events are generated by notifying the adapter server.
  """
  use YProcess, backend: Yggdrasil.Backend 
  use Yggdrasil.Adapter, module: YProcess
  require Logger

  alias Yggdrasil.Adapter
  alias Yggdrasil.Publisher

  ##
  # State for the Elixir adapter. 
  defstruct [:channel, :publisher, :ready, :parent]
  alias __MODULE__, as: State

  ##
  # Generates the `channel` name.
  @doc false
  def get_channel_name(channel) do
    {:elixir_adapter, channel}
  end

  @doc false
  def is_connected?(adapter) do
    YProcess.call(adapter, :connected?)
  end

  @doc false
  def init(%Adapter{publisher: publisher, channel: channel}) do
    adapter_channel = get_channel_name(channel)
    state = %State{channel: adapter_channel, publisher: publisher,
                   ready: false, parent: nil}
    {:join, [adapter_channel], state}
  end

  @doc false
  def ready(:joined, channels, %State{parent: pid} = state) do
    if not is_nil(pid), do: send pid, true
    channel = channels |> List.first |> elem(1)
    Logger.debug("Connected to Elixir #{inspect [channel: channel]}")
    {:noreply, %State{state | ready: true, parent: nil}}
  end

  @doc false
  def handle_call(:connected?, from, %State{ready: false} = state) do
    pid = spawn_link fn ->
      result = receive do
        result -> result
      after
        5000 -> false
      end
      YProcess.reply(from, result)
    end
    {:noreply, %State{state | parent: pid}}
  end
  def handle_call(:connected?, _from, %State{ready: true} = state) do
    {:reply, true, state} 
  end

  @doc false
  def handle_event(
    channel,
    message,
    %State{channel: channel, publisher: publisher} = state
  ) do 
    Publisher.sync_notify(publisher, channel, message)
    {:noreply, state}
  end
  def handle_event(_, _, state) do
   {:noreply, state}
  end
end
